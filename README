# This is a personal project meant to be a virtual machine capable of interpreting
# the TINY Language assembly instructions described by Kenneth Louden in his book
# Compiler Construction, Principles and Practice. The ablity to see how stack
# memory is manipulated at runtime will greatly ease the work of optimizing a
# compiler for the C- (C minus) language. The code is client side only.
# 
# The current version is (should be) hosted as http://burningpotato.com/tm
# If you just want to try it out, skip down to the SAMPLE PROGRAM, which is heapsort.


# INSTALLING
#
# This program is tested with jQuery 1.7.1 and  jQuery UI 1.8.17.
# You will need to modify the links in the document header to point the 
# versions of these libraries that you have. For jQuery UI, you need a
# build with at least the Button, Dialog, Slider, and Tabs widgets (to be safe).
# There is no server component to the VM, it should run on any platform in any
# web browser.


# SAMPLE PROGRAM  P.S. the compiler is currently broken so the sample program...
# well, it runs correctly for a while at least.
     0: LD      4,0(0)	Set GP
     1: ST      0,0(0)	Clear dMem[0]
     2: LDA     7,7(7)	Jump the IO funcs
     3: ST      0,-1(5)	Input Function, store return addr
     4: IN      0,0,0 	     Get input
     5: LD      7,-1(5)	     Return (end of function)
     6: ST      0,-1(5)	Output Function, store return addr
     7: LD      0,-2(5)	     Get output
     8: OUT     0,0,0 	     Give output
     9: LD      7,-1(5)	     Return (end of function)
    10: LDA     5,-12(4)	Set FP below globals
    11: LDA     6,-14(4)	Set SP below globals
    12: LDC     0,14(0)	Load &halt into ac0
    13: LDA     7,413(7)	Jump to main
    14: HALT    0,0,0 	Stop. Hammer-Zeit!
    15: ST      0,-1(5)	Function: store return address in dMem[FP-1]
    16: LD      0,-2(5)	  variable: AC0 = value of variable
    17: ST      0,0(6)	
    18: LDA     6,-1(6)	
    19: LDC     0,2(0)	
    20: LDA     6,1(6)	
    21: LD      1,0(6)	
    22: DIV     0,1,0 	
    23: LD      7,-1(5)	Returning (end of function)
    24: LD      7,-1(5)	Returning (end of function)
    25: ST      0,-1(5)	Function: store return address in dMem[FP-1]
    26: LDC     0,2(0)	
    27: ST      0,0(6)	
    28: LDA     6,-1(6)	
    29: LD      0,-2(5)	  variable: AC0 = value of variable
    30: LDA     6,1(6)	
    31: LD      1,0(6)	
    32: MUL     0,1,0 	
    33: LD      7,-1(5)	Returning (end of function)
    34: LD      7,-1(5)	Returning (end of function)
    35: ST      0,-1(5)	Function: store return address in dMem[FP-1]
    36: LDC     0,2(0)	
    37: ST      0,0(6)	
    38: LDA     6,-1(6)	
    39: LD      0,-2(5)	  variable: AC0 = value of variable
    40: LDA     6,1(6)	
    41: LD      1,0(6)	
    42: MUL     0,1,0 	
    43: ST      0,0(6)	
    44: LDA     6,-1(6)	
    45: LDC     0,1(0)	
    46: LDA     6,1(6)	
    47: LD      1,0(6)	
    48: ADD     0,1,0 	
    49: LD      7,-1(5)	Returning (end of function)
    50: LD      7,-1(5)	Returning (end of function)
    51: ST      0,-1(5)	Function: store return address in dMem[FP-1]
    52: LD      0,-3(5)	  variable: AC0 = value of variable
    53: JGE     0,1(7)	  variable: Jump if subscript >= 0
    54: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
    55: LD      1,-2(5)	
    56: SUB     1,1,0 	
    57: LD      0,0(1)	
    58: ST      0,0(6)	  assignment: save value
    59: LDA     6,-1(6)	
    60: LDA     1,-5(5)	  variable: AC1 = address of variable
    61: LDA     6,1(6)	  assignment: retrieve value
    62: LD      0,0(6)	
    63: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
    64: LD      0,-4(5)	  variable: AC0 = value of variable
    65: JGE     0,1(7)	  variable: Jump if subscript >= 0
    66: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
    67: LD      1,-2(5)	
    68: SUB     1,1,0 	
    69: LD      0,0(1)	
    70: ST      0,0(6)	  assignment: save value
    71: LDA     6,-1(6)	
    72: LDA     1,-6(5)	  variable: AC1 = address of variable
    73: LDA     6,1(6)	  assignment: retrieve value
    74: LD      0,0(6)	
    75: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
    76: LD      0,-6(5)	  variable: AC0 = value of variable
    77: ST      0,0(6)	  assignment: save value
    78: LDA     6,-1(6)	
    79: LD      0,-3(5)	  variable: AC0 = value of variable
    80: JGE     0,1(7)	  variable: Jump if subscript >= 0
    81: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
    82: LD      1,-2(5)	
    83: SUB     1,1,0 	
    84: LDA     6,1(6)	  assignment: retrieve value
    85: LD      0,0(6)	
    86: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
    87: LD      0,-5(5)	  variable: AC0 = value of variable
    88: ST      0,0(6)	  assignment: save value
    89: LDA     6,-1(6)	
    90: LD      0,-4(5)	  variable: AC0 = value of variable
    91: JGE     0,1(7)	  variable: Jump if subscript >= 0
    92: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
    93: LD      1,-2(5)	
    94: SUB     1,1,0 	
    95: LDA     6,1(6)	  assignment: retrieve value
    96: LD      0,0(6)	
    97: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
    98: LD      7,-1(5)	Returning (end of function)
    99: ST      0,-1(5)	Function: store return address in dMem[FP-1]
   100: ST      5,0(6)	     Function call, save old FP
   101: LDA     6,-1(6)	
   102: LDA     6,-1(6)	     Save space for return addr
   103: LD      0,-3(5)	  variable: AC0 = value of variable
   104: ST      0,0(6)	
   105: LDA     6,-1(6)	
   106: LDA     5,3(6)	     Set FP to top of frame
   107: LDA     6,0(6)	     Set SP after locals
   108: LDA     0,1(7)	     Get return addr
   109: LDA     7,-85(7)	     Jump to function
   110: LDA     6,0(5)	     Restore old SP
   111: LD      5,0(5)	     Restore old FP
   112: ST      0,0(6)	  assignment: save value
   113: LDA     6,-1(6)	
   114: LDA     1,-4(5)	  variable: AC1 = address of variable
   115: LDA     6,1(6)	  assignment: retrieve value
   116: LD      0,0(6)	
   117: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   118: ST      5,0(6)	     Function call, save old FP
   119: LDA     6,-1(6)	
   120: LDA     6,-1(6)	     Save space for return addr
   121: LD      0,-3(5)	  variable: AC0 = value of variable
   122: ST      0,0(6)	
   123: LDA     6,-1(6)	
   124: LDA     5,3(6)	     Set FP to top of frame
   125: LDA     6,0(6)	     Set SP after locals
   126: LDA     0,1(7)	     Get return addr
   127: LDA     7,-93(7)	     Jump to function
   128: LDA     6,0(5)	     Restore old SP
   129: LD      5,0(5)	     Restore old FP
   130: ST      0,0(6)	  assignment: save value
   131: LDA     6,-1(6)	
   132: LDA     1,-5(5)	  variable: AC1 = address of variable
   133: LDA     6,1(6)	  assignment: retrieve value
   134: LD      0,0(6)	
   135: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   136: LD      0,-3(5)	  variable: AC0 = value of variable
   137: ST      0,0(6)	  assignment: save value
   138: LDA     6,-1(6)	
   139: LDA     1,-6(5)	  variable: AC1 = address of variable
   140: LDA     6,1(6)	  assignment: retrieve value
   141: LD      0,0(6)	
   142: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   143: LD      0,-4(5)	  variable: AC0 = value of variable
   144: ST      0,0(6)	
   145: LDA     6,-1(6)	
   146: LD      0,0(4)	  variable: AC0 = value of variable
   147: LDA     6,1(6)	
   148: LD      1,0(6)	
   149: SUB     0,1,0 	
   150: JLE     0,3(7)	
   151: LDC     0,0(0)	
   152: LDC     1,0(0)	
   153: JEQ     1,1(7)	
   154: LDC     0,1(0)	
   155: JEQ     0,30(7)	  if test: Jump to end if false (exp == 0)
   156: LD      0,-4(5)	  variable: AC0 = value of variable
   157: JGE     0,1(7)	  variable: Jump if subscript >= 0
   158: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
   159: LD      1,-2(5)	
   160: SUB     1,1,0 	
   161: LD      0,0(1)	
   162: ST      0,0(6)	
   163: LDA     6,-1(6)	
   164: LD      0,-3(5)	  variable: AC0 = value of variable
   165: JGE     0,1(7)	  variable: Jump if subscript >= 0
   166: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
   167: LD      1,-2(5)	
   168: SUB     1,1,0 	
   169: LD      0,0(1)	
   170: LDA     6,1(6)	
   171: LD      1,0(6)	
   172: SUB     0,1,0 	
   173: JGT     0,3(7)	
   174: LDC     0,0(0)	
   175: LDC     1,0(0)	
   176: JEQ     1,1(7)	
   177: LDC     0,1(0)	
   178: JEQ     0,7(7)	  if test: Jump to end if false (exp == 0)
   179: LD      0,-4(5)	  variable: AC0 = value of variable
   180: ST      0,0(6)	  assignment: save value
   181: LDA     6,-1(6)	
   182: LDA     1,-6(5)	  variable: AC1 = address of variable
   183: LDA     6,1(6)	  assignment: retrieve value
   184: LD      0,0(6)	
   185: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   186: LD      0,-5(5)	  variable: AC0 = value of variable
   187: ST      0,0(6)	
   188: LDA     6,-1(6)	
   189: LD      0,0(4)	  variable: AC0 = value of variable
   190: LDA     6,1(6)	
   191: LD      1,0(6)	
   192: SUB     0,1,0 	
   193: JLE     0,3(7)	
   194: LDC     0,0(0)	
   195: LDC     1,0(0)	
   196: JEQ     1,1(7)	
   197: LDC     0,1(0)	
   198: JEQ     0,30(7)	  if test: Jump to end if false (exp == 0)
   199: LD      0,-5(5)	  variable: AC0 = value of variable
   200: JGE     0,1(7)	  variable: Jump if subscript >= 0
   201: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
   202: LD      1,-2(5)	
   203: SUB     1,1,0 	
   204: LD      0,0(1)	
   205: ST      0,0(6)	
   206: LDA     6,-1(6)	
   207: LD      0,-6(5)	  variable: AC0 = value of variable
   208: JGE     0,1(7)	  variable: Jump if subscript >= 0
   209: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
   210: LD      1,-2(5)	
   211: SUB     1,1,0 	
   212: LD      0,0(1)	
   213: LDA     6,1(6)	
   214: LD      1,0(6)	
   215: SUB     0,1,0 	
   216: JGT     0,3(7)	
   217: LDC     0,0(0)	
   218: LDC     1,0(0)	
   219: JEQ     1,1(7)	
   220: LDC     0,1(0)	
   221: JEQ     0,7(7)	  if test: Jump to end if false (exp == 0)
   222: LD      0,-5(5)	  variable: AC0 = value of variable
   223: ST      0,0(6)	  assignment: save value
   224: LDA     6,-1(6)	
   225: LDA     1,-6(5)	  variable: AC1 = address of variable
   226: LDA     6,1(6)	  assignment: retrieve value
   227: LD      0,0(6)	
   228: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   229: LD      0,-6(5)	  variable: AC0 = value of variable
   230: ST      0,0(6)	
   231: LDA     6,-1(6)	
   232: LD      0,-3(5)	  variable: AC0 = value of variable
   233: LDA     6,1(6)	
   234: LD      1,0(6)	
   235: SUB     0,1,0 	
   236: JNE     0,3(7)	
   237: LDC     0,0(0)	
   238: LDC     1,0(0)	
   239: JEQ     1,1(7)	
   240: LDC     0,1(0)	
   241: JEQ     0,33(7)	  if test: Jump to end if false (exp == 0)
   242: ST      5,0(6)	     Function call, save old FP
   243: LDA     6,-1(6)	
   244: LDA     6,-1(6)	     Save space for return addr
   245: LD      0,-2(5)	  variable: AC0 = address of array
   246: ST      0,0(6)	
   247: LDA     6,-1(6)	
   248: LD      0,-3(5)	  variable: AC0 = value of variable
   249: ST      0,0(6)	
   250: LDA     6,-1(6)	
   251: LD      0,-6(5)	  variable: AC0 = value of variable
   252: ST      0,0(6)	
   253: LDA     6,-1(6)	
   254: LDA     5,5(6)	     Set FP to top of frame
   255: LDA     6,-2(6)	     Set SP after locals
   256: LDA     0,1(7)	     Get return addr
   257: LDA     7,-207(7)	     Jump to function
   258: LDA     6,0(5)	     Restore old SP
   259: LD      5,0(5)	     Restore old FP
   260: ST      5,0(6)	     Function call, save old FP
   261: LDA     6,-1(6)	
   262: LDA     6,-1(6)	     Save space for return addr
   263: LD      0,-2(5)	  variable: AC0 = address of array
   264: ST      0,0(6)	
   265: LDA     6,-1(6)	
   266: LD      0,-6(5)	  variable: AC0 = value of variable
   267: ST      0,0(6)	
   268: LDA     6,-1(6)	
   269: LDA     5,4(6)	     Set FP to top of frame
   270: LDA     6,-3(6)	     Set SP after locals
   271: LDA     0,1(7)	     Get return addr
   272: LDA     7,-174(7)	     Jump to function
   273: LDA     6,0(5)	     Restore old SP
   274: LD      5,0(5)	     Restore old FP
   275: LD      7,-1(5)	Returning (end of function)
   276: ST      0,-1(5)	Function: store return address in dMem[FP-1]
   277: LD      0,0(4)	  variable: AC0 = value of variable
   278: ST      0,0(6)	
   279: LDA     6,-1(6)	
   280: LDC     0,2(0)	
   281: LDA     6,1(6)	
   282: LD      1,0(6)	
   283: DIV     0,1,0 	
   284: ST      0,0(6)	  assignment: save value
   285: LDA     6,-1(6)	
   286: LDA     1,-3(5)	  variable: AC1 = address of variable
   287: LDA     6,1(6)	  assignment: retrieve value
   288: LD      0,0(6)	
   289: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   290: LD      0,-3(5)	  variable: AC0 = value of variable
   291: ST      0,0(6)	
   292: LDA     6,-1(6)	
   293: LDC     0,1(0)	
   294: LDA     6,1(6)	
   295: LD      1,0(6)	
   296: SUB     0,1,0 	
   297: JGE     0,3(7)	
   298: LDC     0,0(0)	
   299: LDC     1,0(0)	
   300: JEQ     1,1(7)	
   301: LDC     0,1(0)	
   302: JEQ     0,29(7)	Getta outtatha while
   303: ST      5,0(6)	     Function call, save old FP
   304: LDA     6,-1(6)	
   305: LDA     6,-1(6)	     Save space for return addr
   306: LD      0,-2(5)	  variable: AC0 = address of array
   307: ST      0,0(6)	
   308: LDA     6,-1(6)	
   309: LD      0,-3(5)	  variable: AC0 = value of variable
   310: ST      0,0(6)	
   311: LDA     6,-1(6)	
   312: LDA     5,4(6)	     Set FP to top of frame
   313: LDA     6,-3(6)	     Set SP after locals
   314: LDA     0,1(7)	     Get return addr
   315: LDA     7,-217(7)	     Jump to function
   316: LDA     6,0(5)	     Restore old SP
   317: LD      5,0(5)	     Restore old FP
   318: LD      0,-3(5)	  variable: AC0 = value of variable
   319: ST      0,0(6)	
   320: LDA     6,-1(6)	
   321: LDC     0,1(0)	
   322: LDA     6,1(6)	
   323: LD      1,0(6)	
   324: SUB     0,1,0 	
   325: ST      0,0(6)	  assignment: save value
   326: LDA     6,-1(6)	
   327: LDA     1,-3(5)	  variable: AC1 = address of variable
   328: LDA     6,1(6)	  assignment: retrieve value
   329: LD      0,0(6)	
   330: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   331: JNE     4,-42(7)	Proceed to GO, collect $200
   332: LD      7,-1(5)	Returning (end of function)
   333: ST      0,-1(5)	Function: store return address in dMem[FP-1]
   334: ST      5,0(6)	     Function call, save old FP
   335: LDA     6,-1(6)	
   336: LDA     6,-1(6)	     Save space for return addr
   337: LD      0,-2(5)	  variable: AC0 = address of array
   338: ST      0,0(6)	
   339: LDA     6,-1(6)	
   340: LDA     5,3(6)	     Set FP to top of frame
   341: LDA     6,-1(6)	     Set SP after locals
   342: LDA     0,1(7)	     Get return addr
   343: LDA     7,-68(7)	     Jump to function
   344: LDA     6,0(5)	     Restore old SP
   345: LD      5,0(5)	     Restore old FP
   346: LD      0,0(4)	  variable: AC0 = value of variable
   347: ST      0,0(6)	  assignment: save value
   348: LDA     6,-1(6)	
   349: LDA     1,-3(5)	  variable: AC1 = address of variable
   350: LDA     6,1(6)	  assignment: retrieve value
   351: LD      0,0(6)	
   352: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   353: LD      0,-3(5)	  variable: AC0 = value of variable
   354: ST      0,0(6)	
   355: LDA     6,-1(6)	
   356: LDC     0,2(0)	
   357: LDA     6,1(6)	
   358: LD      1,0(6)	
   359: SUB     0,1,0 	
   360: JGE     0,3(7)	
   361: LDC     0,0(0)	
   362: LDC     1,0(0)	
   363: JEQ     1,1(7)	
   364: LDC     0,1(0)	
   365: JEQ     0,60(7)	Getta outtatha while
   366: ST      5,0(6)	     Function call, save old FP
   367: LDA     6,-1(6)	
   368: LDA     6,-1(6)	     Save space for return addr
   369: LD      0,-2(5)	  variable: AC0 = address of array
   370: ST      0,0(6)	
   371: LDA     6,-1(6)	
   372: LDC     0,1(0)	
   373: ST      0,0(6)	
   374: LDA     6,-1(6)	
   375: LD      0,-3(5)	  variable: AC0 = value of variable
   376: ST      0,0(6)	
   377: LDA     6,-1(6)	
   378: LDA     5,5(6)	     Set FP to top of frame
   379: LDA     6,-2(6)	     Set SP after locals
   380: LDA     0,1(7)	     Get return addr
   381: LDA     7,-331(7)	     Jump to function
   382: LDA     6,0(5)	     Restore old SP
   383: LD      5,0(5)	     Restore old FP
   384: LD      0,0(4)	  variable: AC0 = value of variable
   385: ST      0,0(6)	
   386: LDA     6,-1(6)	
   387: LDC     0,1(0)	
   388: LDA     6,1(6)	
   389: LD      1,0(6)	
   390: SUB     0,1,0 	
   391: ST      0,0(6)	  assignment: save value
   392: LDA     6,-1(6)	
   393: LDA     1,0(4)	  variable: AC1 = address of variable
   394: LDA     6,1(6)	  assignment: retrieve value
   395: LD      0,0(6)	
   396: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   397: ST      5,0(6)	     Function call, save old FP
   398: LDA     6,-1(6)	
   399: LDA     6,-1(6)	     Save space for return addr
   400: LD      0,-2(5)	  variable: AC0 = address of array
   401: ST      0,0(6)	
   402: LDA     6,-1(6)	
   403: LDC     0,1(0)	
   404: ST      0,0(6)	
   405: LDA     6,-1(6)	
   406: LDA     5,4(6)	     Set FP to top of frame
   407: LDA     6,-3(6)	     Set SP after locals
   408: LDA     0,1(7)	     Get return addr
   409: LDA     7,-311(7)	     Jump to function
   410: LDA     6,0(5)	     Restore old SP
   411: LD      5,0(5)	     Restore old FP
   412: LD      0,-3(5)	  variable: AC0 = value of variable
   413: ST      0,0(6)	
   414: LDA     6,-1(6)	
   415: LDC     0,1(0)	
   416: LDA     6,1(6)	
   417: LD      1,0(6)	
   418: SUB     0,1,0 	
   419: ST      0,0(6)	  assignment: save value
   420: LDA     6,-1(6)	
   421: LDA     1,-3(5)	  variable: AC1 = address of variable
   422: LDA     6,1(6)	  assignment: retrieve value
   423: LD      0,0(6)	
   424: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   425: JNE     4,-73(7)	Proceed to GO, collect $200
   426: LD      7,-1(5)	Returning (end of function)
   427: ST      0,-1(5)	Function: store return address in dMem[FP-1]
   428: LDC     0,5(0)	
   429: ST      0,0(6)	  assignment: save value
   430: LDA     6,-1(6)	
   431: LDA     1,0(4)	  variable: AC1 = address of variable
   432: LDA     6,1(6)	  assignment: retrieve value
   433: LD      0,0(6)	
   434: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   435: LDC     0,1(0)	
   436: ST      0,0(6)	  assignment: save value
   437: LDA     6,-1(6)	
   438: LDA     1,-2(5)	  variable: AC1 = address of variable
   439: LDA     6,1(6)	  assignment: retrieve value
   440: LD      0,0(6)	
   441: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   442: LD      0,-2(5)	  variable: AC0 = value of variable
   443: ST      0,0(6)	
   444: LDA     6,-1(6)	
   445: LD      0,0(4)	  variable: AC0 = value of variable
   446: LDA     6,1(6)	
   447: LD      1,0(6)	
   448: SUB     0,1,0 	
   449: JLE     0,3(7)	
   450: LDC     0,0(0)	
   451: LDC     1,0(0)	
   452: JEQ     1,1(7)	
   453: LDC     0,1(0)	
   454: JEQ     0,33(7)	Getta outtatha while
   455: ST      5,0(6)	     Function call, save old FP
   456: LDA     6,-1(6)	
   457: LDA     6,-1(6)	     Save space for return addr
   458: LDA     5,2(6)	     Set FP to top of frame
   459: LDA     6,0(6)	     Set SP after locals
   460: LDA     0,1(7)	     Get return addr
   461: LDA     7,-459(7)	     Jump to function
   462: LDA     6,0(5)	     Restore old SP
   463: LD      5,0(5)	     Restore old FP
   464: ST      0,0(6)	  assignment: save value
   465: LDA     6,-1(6)	
   466: LD      0,-2(5)	  variable: AC0 = value of variable
   467: JGE     0,1(7)	  variable: Jump if subscript >= 0
   468: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
   469: LDA     1,-1(4)	
   470: SUB     1,1,0 	
   471: LDA     6,1(6)	  assignment: retrieve value
   472: LD      0,0(6)	
   473: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   474: LD      0,-2(5)	  variable: AC0 = value of variable
   475: ST      0,0(6)	
   476: LDA     6,-1(6)	
   477: LDC     0,1(0)	
   478: LDA     6,1(6)	
   479: LD      1,0(6)	
   480: ADD     0,1,0 	
   481: ST      0,0(6)	  assignment: save value
   482: LDA     6,-1(6)	
   483: LDA     1,-2(5)	  variable: AC1 = address of variable
   484: LDA     6,1(6)	  assignment: retrieve value
   485: LD      0,0(6)	
   486: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   487: JNE     4,-46(7)	Proceed to GO, collect $200
   488: ST      5,0(6)	     Function call, save old FP
   489: LDA     6,-1(6)	
   490: LDA     6,-1(6)	     Save space for return addr
   491: LDA     0,-1(4)	  variable: AC0 = address of array
   492: ST      0,0(6)	
   493: LDA     6,-1(6)	
   494: LDA     5,3(6)	     Set FP to top of frame
   495: LDA     6,-1(6)	     Set SP after locals
   496: LDA     0,1(7)	     Get return addr
   497: LDA     7,-165(7)	     Jump to function
   498: LDA     6,0(5)	     Restore old SP
   499: LD      5,0(5)	     Restore old FP
   500: LDC     0,1(0)	
   501: ST      0,0(6)	  assignment: save value
   502: LDA     6,-1(6)	
   503: LDA     1,-2(5)	  variable: AC1 = address of variable
   504: LDA     6,1(6)	  assignment: retrieve value
   505: LD      0,0(6)	
   506: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   507: LD      0,-2(5)	  variable: AC0 = value of variable
   508: ST      0,0(6)	
   509: LDA     6,-1(6)	
   510: LD      0,0(4)	  variable: AC0 = value of variable
   511: LDA     6,1(6)	
   512: LD      1,0(6)	
   513: SUB     0,1,0 	
   514: JLE     0,3(7)	
   515: LDC     0,0(0)	
   516: LDC     1,0(0)	
   517: JEQ     1,1(7)	
   518: LDC     0,1(0)	
   519: JEQ     0,31(7)	Getta outtatha while
   520: ST      5,0(6)	     Function call, save old FP
   521: LDA     6,-1(6)	
   522: LDA     6,-1(6)	     Save space for return addr
   523: LD      0,-2(5)	  variable: AC0 = value of variable
   524: JGE     0,1(7)	  variable: Jump if subscript >= 0
   525: HALT    0,0,0 	  variable: Stop. Neg subscripts illegal.
   526: LDA     1,-1(4)	
   527: SUB     1,1,0 	
   528: LD      0,0(1)	
   529: ST      0,0(6)	
   530: LDA     6,-1(6)	
   531: LDA     5,3(6)	     Set FP to top of frame
   532: LDA     6,0(6)	     Set SP after locals
   533: LDA     0,1(7)	     Get return addr
   534: LDA     7,-529(7)	     Jump to function
   535: LDA     6,0(5)	     Restore old SP
   536: LD      5,0(5)	     Restore old FP
   537: LD      0,-2(5)	  variable: AC0 = value of variable
   538: ST      0,0(6)	
   539: LDA     6,-1(6)	
   540: LDC     0,1(0)	
   541: LDA     6,1(6)	
   542: LD      1,0(6)	
   543: ADD     0,1,0 	
   544: ST      0,0(6)	  assignment: save value
   545: LDA     6,-1(6)	
   546: LDA     1,-2(5)	  variable: AC1 = address of variable
   547: LDA     6,1(6)	  assignment: retrieve value
   548: LD      0,0(6)	
   549: ST      0,0(1)	  assignment: variable = dMem[ac1] = value
   550: JNE     4,-44(7)	Proceed to GO, collect $200
   551: LD      7,-1(5)	Returning (end of function)

